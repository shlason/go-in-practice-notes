# Getting into Go

---

### Go 是什麼？
是由 Google 所開發的一種靜態型別、編譯型、並行運算，並具有垃圾回收功能的開源程式語言。
但 Go 並非像傳統的靜態型別和編譯型語言一樣，它擁有一些類似動態型別的特性，以及編譯過後的可執行檔裡就已包含一個有 Garbage Collection 的 Runtime 了。

### Go 有什麼優點？
- 很好的發揮多核心硬體的性能
- 支援跨平台編譯
- 快速及相對簡單的部署
&emsp;&emsp;只需要將編譯出來的二進位執行檔，直接丟到伺服器啟動就好了
- 不用額外設定 Web Server
&emsp;&emsp;不需要 Apache 或 Nginx 等相關服務，Go 本身就可以處理 HTTP 連線，代表不需要伺服器設定，相對的降低維護成本以及伺服器安全性問題

### Go 的缺點
- GC 部分的優化還是比不上 JVM 的 G1
- Go 的編譯器為了編譯速度，將不少編譯時期能做的優化都省略掉了
- 目前還不支援泛型
- 錯誤處理的方式 (但看法兩極)

### Goroutine
非常類似於執行緒，運行是透過多工的方式並行。

每個 OS 執行緒都有固定大小的**堆疊**記憶體區塊 (通常 2 ~ 4MB)，是用來儲存進行中的函式呼叫或呼叫另一個函式而暫時停止時的區域變數的工作區域。

而 goroutine 是可成長的堆疊從 2KB 開始，如同 OS 執行緒一樣 goroutine 的堆疊保存活動中的區域變數與暫停中的函式呼叫，但與 OS 執行緒不同的是 goroutine 的堆疊不是固定的，它會隨著需求而縮放。

Goroutine 可以在 OS 執行緒之間移動，由 Go 排程器來規劃，來最好的運用運算資源，不造成某些執行緒阻塞時而另一個執行緒閒置沒事做。

Go 的執行期本身具有使用稱為 **m:n 排程** 技術的排程器，名稱來自於它在 n 個 OS 執行緒上複合 (排程) m 個 goroutine，Go 排程器的工作類似於 OS 核心排程器，但它只管理單一 Go 程式上的 goroutine。

與 OS 的執行緒排程器不同的是，Go 排程器並非由硬體的計時器週期性來調用，而是由 Go 自己內部特定的結構處理。例如 goroutine 呼叫 time.Sleep 或是受到 channel, mutex 阻斷時，排程器會讓它沈睡並執行其他 goroutine 直到該叫醒它的時候。

由於 OS 執行緒由核心排程，從一個執行緒轉移控制到另一個執行緒需要完整的**背景交換**，也就是儲存一個執行緒的狀態到記憶體中、恢復另一個執行緒的狀態、並更新排程器的資料結構。因為位置性的差異與所需記憶體存取數量，所以這個操作很慢，在存取記憶體所需的 CPU 時脈更多時還會更糟。

由於不需要交換核心背景，因此 goroutine 的重新排程比執行緒的重新排程成本更低。

Go 的排程器使用稱為 GOMAXPROCS 的參數來決定同時有多少 OS 執行緒可以執行 Go 的程式，預設值為該機器的 CPU 數量，這個參數也就是 **m:n 排程** 中的 n。

Goroutine 沒有識別名稱，是當初設計上有意而為之的，設計者認為執行緒區域儲存體常常被濫用，就像大量依賴全域變數一樣，會引發**超距作用**也就是函式的行為並非完全由所帶入的參數決定，而是執行緒的識別名稱來決定。

Never start a goroutine without knowning when it will stop.

### Channel
用來讓 goroutine 間可以互相發送值的一個通訊機制。


### 參考來源
[The Go Programming Language - 2015 - Oreilly](https://www.gopl.io/)